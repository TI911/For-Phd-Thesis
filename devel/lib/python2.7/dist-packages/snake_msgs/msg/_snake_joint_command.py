# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from snake_msgs/snake_joint_command.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class snake_joint_command(genpy.Message):
  _md5sum = "9b9655538a9e6ed977cf332db5dc463c"
  _type = "snake_msgs/snake_joint_command"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """###############################################################################
# snake_robot_master nodeに送るコマンド
# 実行したいコマンドをtrueにしてpublishすると実行される
# 送信するデータがあるものは該当するデータを埋めてからpublishすること
# 対象の関節をjoint_indexで指定するか，全ての関節を対象とする場合はtarget_allをtrueにする
#
# KONDO B3MシリーズとDynamixelシリーズで違いがある．
# 対応しているかどうかは各コマンドのコメントに記載する．
# KONDOが<K>, Dynamixelが<D>であり，書かれているものには対応している
###############################################################################

#--- 対称を指定
uint8 joint_index  # index number of joint
bool target_all  # 全ての関節を対象とする場合はこれをtrueにする．その場合joint_indexは無意味

#--- IDリスト
bool set_id_list  # Slave MCU　にサーボのIDを記録する
bool read_id_list  # Slave MCU　からサーボのIDリストを読み出す

#--- サーボの状態
bool ping  # <KD> サーボの存在確認
bool reset  # <K> サーボをリセットする
bool clear_error  # <KD>　エラーによる停止状態を解除する

bool change_mode_to_hold  # <K>　モーターブレーキモードにする
bool change_mode_to_free  # <KD>　モーターをフリーにする
bool change_mode_to_active  # <KD>　モーターの制御を有効化する．トルクが入る

#--- 書き込み
bool set_position  # <KD>　目標位置を指示する target_positionが必要
bool set_position_time  # <K>　目標位置と到達時間を指示する target_position, target_timeが必要
bool set_position_velosity  # <D>　目標位置とそこに向かう速さを指示する target_position, target_velosityが必要
float64 target_position  # [deg]
float64 target_time  # [sec]
float64 target_velosity  # [deg/sec]

# <KD>　PIDゲインを設定する．
# KONDOの場合はデフォルト値に対する割合，
# Dynamixelの場合はそのまま書き込まれる値
bool set_pid_gain  
uint32 p_gain  # KONDO:[%], Dynamixel:[-]
uint32 i_gain  # KONDO:[%], Dynamixel:[-]
uint32 d_gain  # KONDO:[%], Dynamixel:[-]

bool set_lock_parameter  # <K>　LOCK検出に関するパラメータを設定する
uint8 lock_time_value  # [msec] この時間だけlock_output_valueを越えるとLOCK判定
uint8 lock_output_value  # [%] lock_time_valueだけこの値を越えるとLOCK判定
uint8 lock_power_value  # [%] LOCK判定後，出力をこの割合に絞る

#--- 読み込み
bool read_position  # [deg] 位置の読み込み
bool read_velosity  # [deg/sec] 角速度の読み込み
bool read_current  # [A] モーター電流の読み込み
bool read_voltage  # [V] サーボへの入力電圧の読み込み
bool read_motor_temperature  # [degC] モーター温度の読み込み
bool read_position_velosity  # [deg][deg/sec] 位置と角速度の読み込み
bool read_position_current  # [deg][A] 位置と電流の読み込み
bool read_position_velosity_current  # [deg][deg/sec][A] 位置と角速度と電流の読み込み

#--- アドレスを指定してパラメータを操作
bool set_parameter_by_address
uint8 address_to_set
uint8 length_set  # 1~7 書き込むデータのバイト数
uint8[] data_to_set

bool read_parameter_by_address
uint8 address_to_read
uint8 length_read  # 1~7 読み込むデータのバイト数
"""
  __slots__ = ['joint_index','target_all','set_id_list','read_id_list','ping','reset','clear_error','change_mode_to_hold','change_mode_to_free','change_mode_to_active','set_position','set_position_time','set_position_velosity','target_position','target_time','target_velosity','set_pid_gain','p_gain','i_gain','d_gain','set_lock_parameter','lock_time_value','lock_output_value','lock_power_value','read_position','read_velosity','read_current','read_voltage','read_motor_temperature','read_position_velosity','read_position_current','read_position_velosity_current','set_parameter_by_address','address_to_set','length_set','data_to_set','read_parameter_by_address','address_to_read','length_read']
  _slot_types = ['uint8','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','float64','float64','float64','bool','uint32','uint32','uint32','bool','uint8','uint8','uint8','bool','bool','bool','bool','bool','bool','bool','bool','bool','uint8','uint8','uint8[]','bool','uint8','uint8']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       joint_index,target_all,set_id_list,read_id_list,ping,reset,clear_error,change_mode_to_hold,change_mode_to_free,change_mode_to_active,set_position,set_position_time,set_position_velosity,target_position,target_time,target_velosity,set_pid_gain,p_gain,i_gain,d_gain,set_lock_parameter,lock_time_value,lock_output_value,lock_power_value,read_position,read_velosity,read_current,read_voltage,read_motor_temperature,read_position_velosity,read_position_current,read_position_velosity_current,set_parameter_by_address,address_to_set,length_set,data_to_set,read_parameter_by_address,address_to_read,length_read

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(snake_joint_command, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.joint_index is None:
        self.joint_index = 0
      if self.target_all is None:
        self.target_all = False
      if self.set_id_list is None:
        self.set_id_list = False
      if self.read_id_list is None:
        self.read_id_list = False
      if self.ping is None:
        self.ping = False
      if self.reset is None:
        self.reset = False
      if self.clear_error is None:
        self.clear_error = False
      if self.change_mode_to_hold is None:
        self.change_mode_to_hold = False
      if self.change_mode_to_free is None:
        self.change_mode_to_free = False
      if self.change_mode_to_active is None:
        self.change_mode_to_active = False
      if self.set_position is None:
        self.set_position = False
      if self.set_position_time is None:
        self.set_position_time = False
      if self.set_position_velosity is None:
        self.set_position_velosity = False
      if self.target_position is None:
        self.target_position = 0.
      if self.target_time is None:
        self.target_time = 0.
      if self.target_velosity is None:
        self.target_velosity = 0.
      if self.set_pid_gain is None:
        self.set_pid_gain = False
      if self.p_gain is None:
        self.p_gain = 0
      if self.i_gain is None:
        self.i_gain = 0
      if self.d_gain is None:
        self.d_gain = 0
      if self.set_lock_parameter is None:
        self.set_lock_parameter = False
      if self.lock_time_value is None:
        self.lock_time_value = 0
      if self.lock_output_value is None:
        self.lock_output_value = 0
      if self.lock_power_value is None:
        self.lock_power_value = 0
      if self.read_position is None:
        self.read_position = False
      if self.read_velosity is None:
        self.read_velosity = False
      if self.read_current is None:
        self.read_current = False
      if self.read_voltage is None:
        self.read_voltage = False
      if self.read_motor_temperature is None:
        self.read_motor_temperature = False
      if self.read_position_velosity is None:
        self.read_position_velosity = False
      if self.read_position_current is None:
        self.read_position_current = False
      if self.read_position_velosity_current is None:
        self.read_position_velosity_current = False
      if self.set_parameter_by_address is None:
        self.set_parameter_by_address = False
      if self.address_to_set is None:
        self.address_to_set = 0
      if self.length_set is None:
        self.length_set = 0
      if self.data_to_set is None:
        self.data_to_set = ''
      if self.read_parameter_by_address is None:
        self.read_parameter_by_address = False
      if self.address_to_read is None:
        self.address_to_read = 0
      if self.length_read is None:
        self.length_read = 0
    else:
      self.joint_index = 0
      self.target_all = False
      self.set_id_list = False
      self.read_id_list = False
      self.ping = False
      self.reset = False
      self.clear_error = False
      self.change_mode_to_hold = False
      self.change_mode_to_free = False
      self.change_mode_to_active = False
      self.set_position = False
      self.set_position_time = False
      self.set_position_velosity = False
      self.target_position = 0.
      self.target_time = 0.
      self.target_velosity = 0.
      self.set_pid_gain = False
      self.p_gain = 0
      self.i_gain = 0
      self.d_gain = 0
      self.set_lock_parameter = False
      self.lock_time_value = 0
      self.lock_output_value = 0
      self.lock_power_value = 0
      self.read_position = False
      self.read_velosity = False
      self.read_current = False
      self.read_voltage = False
      self.read_motor_temperature = False
      self.read_position_velosity = False
      self.read_position_current = False
      self.read_position_velosity_current = False
      self.set_parameter_by_address = False
      self.address_to_set = 0
      self.length_set = 0
      self.data_to_set = ''
      self.read_parameter_by_address = False
      self.address_to_read = 0
      self.length_read = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_13B3dB3I15B.pack(_x.joint_index, _x.target_all, _x.set_id_list, _x.read_id_list, _x.ping, _x.reset, _x.clear_error, _x.change_mode_to_hold, _x.change_mode_to_free, _x.change_mode_to_active, _x.set_position, _x.set_position_time, _x.set_position_velosity, _x.target_position, _x.target_time, _x.target_velosity, _x.set_pid_gain, _x.p_gain, _x.i_gain, _x.d_gain, _x.set_lock_parameter, _x.lock_time_value, _x.lock_output_value, _x.lock_power_value, _x.read_position, _x.read_velosity, _x.read_current, _x.read_voltage, _x.read_motor_temperature, _x.read_position_velosity, _x.read_position_current, _x.read_position_velosity_current, _x.set_parameter_by_address, _x.address_to_set, _x.length_set))
      _x = self.data_to_set
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_3B.pack(_x.read_parameter_by_address, _x.address_to_read, _x.length_read))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      end = 0
      _x = self
      start = end
      end += 65
      (_x.joint_index, _x.target_all, _x.set_id_list, _x.read_id_list, _x.ping, _x.reset, _x.clear_error, _x.change_mode_to_hold, _x.change_mode_to_free, _x.change_mode_to_active, _x.set_position, _x.set_position_time, _x.set_position_velosity, _x.target_position, _x.target_time, _x.target_velosity, _x.set_pid_gain, _x.p_gain, _x.i_gain, _x.d_gain, _x.set_lock_parameter, _x.lock_time_value, _x.lock_output_value, _x.lock_power_value, _x.read_position, _x.read_velosity, _x.read_current, _x.read_voltage, _x.read_motor_temperature, _x.read_position_velosity, _x.read_position_current, _x.read_position_velosity_current, _x.set_parameter_by_address, _x.address_to_set, _x.length_set,) = _struct_13B3dB3I15B.unpack(str[start:end])
      self.target_all = bool(self.target_all)
      self.set_id_list = bool(self.set_id_list)
      self.read_id_list = bool(self.read_id_list)
      self.ping = bool(self.ping)
      self.reset = bool(self.reset)
      self.clear_error = bool(self.clear_error)
      self.change_mode_to_hold = bool(self.change_mode_to_hold)
      self.change_mode_to_free = bool(self.change_mode_to_free)
      self.change_mode_to_active = bool(self.change_mode_to_active)
      self.set_position = bool(self.set_position)
      self.set_position_time = bool(self.set_position_time)
      self.set_position_velosity = bool(self.set_position_velosity)
      self.set_pid_gain = bool(self.set_pid_gain)
      self.set_lock_parameter = bool(self.set_lock_parameter)
      self.read_position = bool(self.read_position)
      self.read_velosity = bool(self.read_velosity)
      self.read_current = bool(self.read_current)
      self.read_voltage = bool(self.read_voltage)
      self.read_motor_temperature = bool(self.read_motor_temperature)
      self.read_position_velosity = bool(self.read_position_velosity)
      self.read_position_current = bool(self.read_position_current)
      self.read_position_velosity_current = bool(self.read_position_velosity_current)
      self.set_parameter_by_address = bool(self.set_parameter_by_address)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.data_to_set = str[start:end]
      _x = self
      start = end
      end += 3
      (_x.read_parameter_by_address, _x.address_to_read, _x.length_read,) = _struct_3B.unpack(str[start:end])
      self.read_parameter_by_address = bool(self.read_parameter_by_address)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_13B3dB3I15B.pack(_x.joint_index, _x.target_all, _x.set_id_list, _x.read_id_list, _x.ping, _x.reset, _x.clear_error, _x.change_mode_to_hold, _x.change_mode_to_free, _x.change_mode_to_active, _x.set_position, _x.set_position_time, _x.set_position_velosity, _x.target_position, _x.target_time, _x.target_velosity, _x.set_pid_gain, _x.p_gain, _x.i_gain, _x.d_gain, _x.set_lock_parameter, _x.lock_time_value, _x.lock_output_value, _x.lock_power_value, _x.read_position, _x.read_velosity, _x.read_current, _x.read_voltage, _x.read_motor_temperature, _x.read_position_velosity, _x.read_position_current, _x.read_position_velosity_current, _x.set_parameter_by_address, _x.address_to_set, _x.length_set))
      _x = self.data_to_set
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_3B.pack(_x.read_parameter_by_address, _x.address_to_read, _x.length_read))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      end = 0
      _x = self
      start = end
      end += 65
      (_x.joint_index, _x.target_all, _x.set_id_list, _x.read_id_list, _x.ping, _x.reset, _x.clear_error, _x.change_mode_to_hold, _x.change_mode_to_free, _x.change_mode_to_active, _x.set_position, _x.set_position_time, _x.set_position_velosity, _x.target_position, _x.target_time, _x.target_velosity, _x.set_pid_gain, _x.p_gain, _x.i_gain, _x.d_gain, _x.set_lock_parameter, _x.lock_time_value, _x.lock_output_value, _x.lock_power_value, _x.read_position, _x.read_velosity, _x.read_current, _x.read_voltage, _x.read_motor_temperature, _x.read_position_velosity, _x.read_position_current, _x.read_position_velosity_current, _x.set_parameter_by_address, _x.address_to_set, _x.length_set,) = _struct_13B3dB3I15B.unpack(str[start:end])
      self.target_all = bool(self.target_all)
      self.set_id_list = bool(self.set_id_list)
      self.read_id_list = bool(self.read_id_list)
      self.ping = bool(self.ping)
      self.reset = bool(self.reset)
      self.clear_error = bool(self.clear_error)
      self.change_mode_to_hold = bool(self.change_mode_to_hold)
      self.change_mode_to_free = bool(self.change_mode_to_free)
      self.change_mode_to_active = bool(self.change_mode_to_active)
      self.set_position = bool(self.set_position)
      self.set_position_time = bool(self.set_position_time)
      self.set_position_velosity = bool(self.set_position_velosity)
      self.set_pid_gain = bool(self.set_pid_gain)
      self.set_lock_parameter = bool(self.set_lock_parameter)
      self.read_position = bool(self.read_position)
      self.read_velosity = bool(self.read_velosity)
      self.read_current = bool(self.read_current)
      self.read_voltage = bool(self.read_voltage)
      self.read_motor_temperature = bool(self.read_motor_temperature)
      self.read_position_velosity = bool(self.read_position_velosity)
      self.read_position_current = bool(self.read_position_current)
      self.read_position_velosity_current = bool(self.read_position_velosity_current)
      self.set_parameter_by_address = bool(self.set_parameter_by_address)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.data_to_set = str[start:end]
      _x = self
      start = end
      end += 3
      (_x.read_parameter_by_address, _x.address_to_read, _x.length_read,) = _struct_3B.unpack(str[start:end])
      self.read_parameter_by_address = bool(self.read_parameter_by_address)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_3B = struct.Struct("<3B")
_struct_13B3dB3I15B = struct.Struct("<13B3dB3I15B")
